# å¤šå¹³å°æ¸¸æˆä¸ç¬¬ä¸‰æ–¹ç™»å½•å®æ–½æŒ‡å—

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2024-11-12  
**é€‚ç”¨é¡¹ç›®**: GameHub å°æ¸¸æˆèšåˆå¹³å°  
**å®æ–½å‘¨æœŸ**: 4-6 å‘¨

---

## ğŸ¯ å®æ–½ç›®æ ‡

### éœ€æ±‚ä¸€ï¼šå¤šå¹³å°æ¸¸æˆæ”¯æŒ

**ç›®æ ‡**ï¼šæ”¯æŒ HTML5ã€å¾®ä¿¡å°æ¸¸æˆã€æŠ–éŸ³å°æ¸¸æˆä¸‰ç§æ¸¸æˆå¹³å°

**ä¸šåŠ¡ä»·å€¼**ï¼š
- æ‰©å¤§æ¸¸æˆèµ„æºæ± ï¼Œå¢åŠ å¹³å°å†…å®¹ä¸°å¯Œåº¦
- æå‡ç”¨æˆ·ç•™å­˜ï¼Œæ»¡è¶³ä¸åŒç”¨æˆ·çš„æ¸¸æˆåå¥½
- æ‰“é€šå¾®ä¿¡ã€æŠ–éŸ³ç”Ÿæ€ï¼Œè·å–æ›´å¤šæµé‡

**æŠ€æœ¯æŒ‡æ ‡**ï¼š
- æ”¯æŒ 3+ æ¸¸æˆå¹³å°
- æ¸¸æˆå¯åŠ¨æˆåŠŸç‡ > 95%
- å¹³å°åˆ‡æ¢æ— æ„ŸçŸ¥
- API å“åº”æ—¶é—´ < 200ms

### éœ€æ±‚äºŒï¼šå¤šå¹³å°ç¬¬ä¸‰æ–¹ç™»å½•

**ç›®æ ‡**ï¼šé›†æˆå¾®ä¿¡ã€QQã€æ”¯ä»˜å®ã€å¾®åšã€æŠ–éŸ³ã€Apple IDã€Google å…± 7 ç§ç¬¬ä¸‰æ–¹ç™»å½•æ–¹å¼

**ä¸šåŠ¡ä»·å€¼**ï¼š
- é™ä½æ³¨å†Œé—¨æ§›ï¼Œæå‡ç”¨æˆ·æ³¨å†Œè½¬åŒ–ç‡
- è·å–æ›´ä¸°å¯Œçš„ç”¨æˆ·ç”»åƒæ•°æ®
- æå‡ç”¨æˆ·ä½“éªŒï¼Œä¸€é”®ç™»å½•

**æŠ€æœ¯æŒ‡æ ‡**ï¼š
- æ”¯æŒ 7+ ç™»å½•æ–¹å¼
- OAuth æˆæƒæˆåŠŸç‡ > 98%
- ç™»å½•å“åº”æ—¶é—´ < 1s
- æ”¯æŒè´¦å·ç»‘å®šå’Œè§£ç»‘

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯å±‚ (Frontend)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¸¸æˆåŠ è½½å™¨        â”‚  å¹³å°æ£€æµ‹å™¨    â”‚  ç¬¬ä¸‰æ–¹ç™»å½•ç»„ä»¶    â”‚
â”‚  GameLoader       â”‚  Platform      â”‚  OAuth Buttons    â”‚
â”‚                   â”‚  Detector      â”‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚              â”‚             â”‚
             â–¼              â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åç«¯å±‚ (Backend)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¸¸æˆå¹³å°æœåŠ¡      â”‚  å¹³å°é€‚é…å™¨    â”‚  OAuth æœåŠ¡        â”‚
â”‚  Platform Service â”‚  Adapters      â”‚  OAuth Service    â”‚
â”‚                   â”‚  - HTML5       â”‚  - WeChat         â”‚
â”‚                   â”‚  - WeChat      â”‚  - Alipay         â”‚
â”‚                   â”‚  - Douyin      â”‚  - Weibo          â”‚
â”‚                   â”‚                â”‚  - Douyin         â”‚
â”‚                   â”‚                â”‚  - Google         â”‚
â”‚                   â”‚                â”‚  - Apple          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚              â”‚             â”‚
             â–¼              â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ•°æ®å±‚ (Database)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  games è¡¨         â”‚  user_auth_methods è¡¨                â”‚
â”‚  + platform       â”‚  + æ‰©å±• auth_type                    â”‚
â”‚  + load_type      â”‚  + provider_data                     â”‚
â”‚  + platform_configâ”‚  + is_primary                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### æ•´ä½“æ—¶é—´çº¿

| é˜¶æ®µ | ä»»åŠ¡ | å‘¨æœŸ | ä¾èµ– |
|------|------|------|------|
| Phase 1 | å¤šå¹³å°æ¸¸æˆæ”¯æŒ - æ•°æ®åº“è®¾è®¡ | 2 å¤© | - |
| Phase 2 | å¤šå¹³å°æ¸¸æˆæ”¯æŒ - åç«¯å®ç° | 1 å‘¨ | Phase 1 |
| Phase 3 | å¤šå¹³å°æ¸¸æˆæ”¯æŒ - å‰ç«¯å®ç° | 1 å‘¨ | Phase 2 |
| Phase 4 | å¤šå¹³å°æ¸¸æˆæ”¯æŒ - æµ‹è¯•ä¼˜åŒ– | 3 å¤© | Phase 3 |
| Phase 5 | ç¬¬ä¸‰æ–¹ç™»å½• - åç«¯å®ç° | 1 å‘¨ | - |
| Phase 6 | ç¬¬ä¸‰æ–¹ç™»å½• - å‰ç«¯å®ç° | 1 å‘¨ | Phase 5 |
| Phase 7 | ç¬¬ä¸‰æ–¹ç™»å½• - æµ‹è¯•ä¼˜åŒ– | 3 å¤© | Phase 6 |
| Phase 8 | é›†æˆæµ‹è¯•ä¸ä¸Šçº¿å‡†å¤‡ | 3 å¤© | All |

**æ€»è®¡**: 4-6 å‘¨

---

## ğŸš€ éœ€æ±‚ä¸€ï¼šå¤šå¹³å°æ¸¸æˆæ”¯æŒ

### Phase 1: æ•°æ®åº“è®¾è®¡ä¸è¿ç§» (2å¤©)

#### æ­¥éª¤ 1.1: è®¾è®¡æ•°æ®åº“è¡¨ç»“æ„

**ç›®æ ‡**: æ‰©å±• games è¡¨ä»¥æ”¯æŒå¤šå¹³å°

**æ–°å¢å­—æ®µ**:

```sql
-- æ¸¸æˆå¹³å°ç±»å‹
platform VARCHAR(20) NOT NULL DEFAULT 'html5'
  -- å¯é€‰å€¼: 'html5', 'wechat', 'douyin', 'native'

-- åŠ è½½æ–¹å¼
load_type VARCHAR(20) NOT NULL DEFAULT 'iframe'
  -- å¯é€‰å€¼: 'iframe', 'sdk', 'native_app', 'mini_program'

-- å¹³å°ç‰¹å®šé…ç½® (JSONB)
platform_config JSONB NULL
  -- å­˜å‚¨å„å¹³å°çš„é…ç½®å‚æ•°

-- æ”¯æŒçš„å¹³å°åˆ—è¡¨ (JSONB Array)
supported_platforms JSONB NOT NULL DEFAULT '["html5"]'
  -- æ¸¸æˆå¯èƒ½æ”¯æŒå¤šä¸ªå¹³å°
```

**platform_config ç»“æ„ç¤ºä¾‹**:

```json
{
  // HTML5 é…ç½®
  "iframe_url": "https://example.com/game.html",
  "sandbox_permissions": [
    "allow-scripts",
    "allow-same-origin",
    "allow-popups"
  ],
  
  // å¾®ä¿¡å°æ¸¸æˆé…ç½®
  "wechat_app_id": "wx1234567890abcdef",
  "wechat_path": "pages/index/index",
  "wechat_version": "release",
  
  // æŠ–éŸ³å°æ¸¸æˆé…ç½®
  "douyin_app_id": "tt1234567890",
  "douyin_path": "pages/game/index",
  "douyin_version": "1.0.0",
  
  // é€šç”¨é…ç½®
  "supported_devices": ["ios", "android", "web"],
  "min_client_version": "1.0.0"
}
```

#### æ­¥éª¤ 1.2: åˆ›å»ºæ•°æ®åº“è¿ç§»æ–‡ä»¶

**æ–‡ä»¶**: `backend/src/database/migrations/010_add_game_platforms.ts`

```typescript
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';

export class AddGamePlatforms1699999999999 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // 1. æ·»åŠ  platform å­—æ®µ
    await queryRunner.addColumn(
      'games',
      new TableColumn({
        name: 'platform',
        type: 'varchar',
        length: '20',
        default: "'html5'",
        isNullable: false,
      })
    );

    // 2. æ·»åŠ  load_type å­—æ®µ
    await queryRunner.addColumn(
      'games',
      new TableColumn({
        name: 'load_type',
        type: 'varchar',
        length: '20',
        default: "'iframe'",
        isNullable: false,
      })
    );

    // 3. æ·»åŠ  platform_config å­—æ®µ
    await queryRunner.addColumn(
      'games',
      new TableColumn({
        name: 'platform_config',
        type: 'jsonb',
        isNullable: true,
      })
    );

    // 4. æ·»åŠ  supported_platforms å­—æ®µ
    await queryRunner.addColumn(
      'games',
      new TableColumn({
        name: 'supported_platforms',
        type: 'jsonb',
        default: "'[\"html5\"]'",
        isNullable: false,
      })
    );

    // 5. åˆ›å»ºç´¢å¼•
    await queryRunner.query(
      `CREATE INDEX "IDX_games_platform" ON "games" ("platform")`
    );

    // 6. åˆ›å»ºå¤åˆç´¢å¼•ï¼ˆç”¨äºæŒ‰å¹³å°ç­›é€‰æ´»è·ƒæ¸¸æˆï¼‰
    await queryRunner.query(
      `CREATE INDEX "IDX_games_platform_status" 
       ON "games" ("platform", "availability_status")`
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX "IDX_games_platform_status"`);
    await queryRunner.query(`DROP INDEX "IDX_games_platform"`);
    await queryRunner.dropColumn('games', 'supported_platforms');
    await queryRunner.dropColumn('games', 'platform_config');
    await queryRunner.dropColumn('games', 'load_type');
    await queryRunner.dropColumn('games', 'platform');
  }
}
```

**æ‰§è¡Œè¿ç§»**:

```bash
cd backend
npm run migration:run
```

#### æ­¥éª¤ 1.3: æ›´æ–° Game å®ä½“

**æ–‡ä»¶**: `backend/src/modules/games/entities/game.entity.ts`

**æ·»åŠ çš„ä»£ç **:

```typescript
// åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ æšä¸¾å®šä¹‰
export enum GamePlatform {
  HTML5 = 'html5',
  WECHAT = 'wechat',
  DOUYIN = 'douyin',
  NATIVE = 'native',
}

export enum GameLoadType {
  IFRAME = 'iframe',
  SDK = 'sdk',
  NATIVE_APP = 'native_app',
  MINI_PROGRAM = 'mini_program',
}

export interface PlatformConfig {
  // HTML5 é…ç½®
  iframe_url?: string;
  sandbox_permissions?: string[];
  
  // å¾®ä¿¡å°æ¸¸æˆé…ç½®
  wechat_app_id?: string;
  wechat_path?: string;
  wechat_version?: string;
  
  // æŠ–éŸ³å°æ¸¸æˆé…ç½®
  douyin_app_id?: string;
  douyin_path?: string;
  douyin_version?: string;
  
  // é€šç”¨é…ç½®
  supported_devices?: ('ios' | 'android' | 'web')[];
  min_client_version?: string;
}

// åœ¨ Game ç±»ä¸­æ·»åŠ æ–°å­—æ®µ
@Entity('games')
export class Game {
  // ... ç°æœ‰å­—æ®µ ...

  @Column({
    type: 'varchar',
    length: 20,
    default: GamePlatform.HTML5,
  })
  platform: GamePlatform;

  @Column({
    type: 'varchar',
    length: 20,
    default: GameLoadType.IFRAME,
    name: 'load_type',
  })
  loadType: GameLoadType;

  @Column({
    type: 'jsonb',
    nullable: true,
    name: 'platform_config',
  })
  platformConfig: PlatformConfig | null;

  @Column({
    type: 'jsonb',
    default: ['html5'],
    name: 'supported_platforms',
  })
  supportedPlatforms: GamePlatform[];

  // è¾…åŠ©æ–¹æ³•
  supportsCurrentPlatform(currentPlatform: GamePlatform): boolean {
    return this.supportedPlatforms.includes(currentPlatform);
  }

  getPlatformConfig<T extends keyof PlatformConfig>(
    key: T
  ): PlatformConfig[T] | undefined {
    return this.platformConfig?.[key];
  }
}
```

---

### Phase 2: åç«¯å¹³å°é€‚é…å™¨å®ç° (1å‘¨)

#### æ­¥éª¤ 2.1: åˆ›å»ºåŸºç¡€é€‚é…å™¨æ¥å£

**æ–‡ä»¶**: `backend/src/modules/games/services/platform-adapters/base.adapter.ts`

```typescript
import { Game } from '../../entities/game.entity';
import { PlatformConfig } from '../../entities/game.entity';

export interface GameLaunchParams {
  gameId: string;
  userId: string;
  sessionId: string;
  platform: string;
  userAgent?: string;
}

export interface GameLaunchResult {
  success: boolean;
  launchUrl?: string;
  launchData?: any;
  error?: string;
  qrCodeUrl?: string;
}

export abstract class BasePlatformAdapter {
  /**
   * éªŒè¯å¹³å°é…ç½®æ˜¯å¦å®Œæ•´
   */
  abstract validateConfig(config: PlatformConfig): boolean;

  /**
   * å‡†å¤‡æ¸¸æˆå¯åŠ¨
   */
  abstract prepareLaunch(
    game: Game,
    params: GameLaunchParams
  ): Promise<GameLaunchResult>;

  /**
   * è·Ÿè¸ªæ¸¸æˆä¼šè¯
   */
  abstract trackSession(sessionId: string, data: any): Promise<void>;

  /**
   * ç”ŸæˆäºŒç»´ç ï¼ˆå¯é€‰ï¼‰
   */
  async generateQRCode?(game: Game, sessionId: string): Promise<Buffer>;
}
```

#### æ­¥éª¤ 2.2: å®ç° HTML5 é€‚é…å™¨

**æ–‡ä»¶**: `backend/src/modules/games/services/platform-adapters/html5.adapter.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { BasePlatformAdapter, GameLaunchParams, GameLaunchResult } from './base.adapter';
import { Game, PlatformConfig } from '../../entities/game.entity';

@Injectable()
export class Html5Adapter extends BasePlatformAdapter {
  validateConfig(config: PlatformConfig): boolean {
    // HTML5 æ¸¸æˆåªéœ€è¦æœ‰ game_url æˆ– iframe_url
    return !!(config?.iframe_url);
  }

  async prepareLaunch(
    game: Game,
    params: GameLaunchParams
  ): Promise<GameLaunchResult> {
    // éªŒè¯æ¸¸æˆURL
    const gameUrl = game.platformConfig?.iframe_url || game.gameUrl;
    
    if (!gameUrl) {
      return {
        success: false,
        error: 'Game URL not configured',
      };
    }

    // ç”Ÿæˆå¸¦å‚æ•°çš„æ¸¸æˆURLï¼ˆç”¨äºä¼šè¯è·Ÿè¸ªå’Œç§¯åˆ†è®¡ç®—ï¼‰
    const launchUrl = this.buildGameUrl(gameUrl, {
      session_id: params.sessionId,
      user_id: params.userId,
      game_id: params.gameId,
      timestamp: Date.now().toString(),
    });

    return {
      success: true,
      launchUrl,
      launchData: {
        type: 'iframe',
        url: launchUrl,
        sandbox: game.platformConfig?.sandbox_permissions || [
          'allow-scripts',
          'allow-same-origin',
          'allow-popups',
          'allow-forms',
        ],
      },
    };
  }

  async trackSession(sessionId: string, data: any): Promise<void> {
    // HTML5 æ¸¸æˆçš„ä¼šè¯è·Ÿè¸ª
    // é€šè¿‡ postMessage ä¸ iframe é€šä¿¡
    console.log(`Tracking HTML5 session: ${sessionId}`, data);
  }

  private buildGameUrl(
    baseUrl: string,
    params: Record<string, string>
  ): string {
    try {
      const url = new URL(baseUrl);
      Object.entries(params).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
      return url.toString();
    } catch (error) {
      // å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„URLï¼Œè¿”å›åŸå§‹URL
      return baseUrl;
    }
  }
}
```

#### æ­¥éª¤ 2.3: å®ç°å¾®ä¿¡å°æ¸¸æˆé€‚é…å™¨

**æ–‡ä»¶**: `backend/src/modules/games/services/platform-adapters/wechat.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { firstValueFrom } from 'rxjs';
import { BasePlatformAdapter, GameLaunchParams, GameLaunchResult } from './base.adapter';
import { Game, PlatformConfig } from '../../entities/game.entity';

@Injectable()
export class WechatAdapter extends BasePlatformAdapter {
  private readonly logger = new Logger(WechatAdapter.name);
  private accessToken: string | null = null;
  private tokenExpireTime: number = 0;

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
  ) {
    super();
  }

  validateConfig(config: PlatformConfig): boolean {
    return !!(config?.wechat_app_id && config?.wechat_path);
  }

  async prepareLaunch(
    game: Game,
    params: GameLaunchParams
  ): Promise<GameLaunchResult> {
    const config = game.platformConfig;
    
    if (!this.validateConfig(config)) {
      return {
        success: false,
        error: 'WeChat mini-game configuration incomplete',
      };
    }

    // ç”Ÿæˆå¾®ä¿¡å°æ¸¸æˆå¯åŠ¨å‚æ•°
    const query = new URLSearchParams({
      session_id: params.sessionId,
      user_id: params.userId,
      game_id: params.gameId,
    }).toString();

    // å¾®ä¿¡å°æ¸¸æˆ URL Scheme
    const launchUrl = `weixin://dl/minigame/${config.wechat_app_id}`;

    return {
      success: true,
      launchUrl,
      launchData: {
        type: 'wechat_mini_game',
        appId: config.wechat_app_id,
        path: config.wechat_path || 'pages/index/index',
        query,
        envVersion: config.wechat_version || 'release',
      },
    };
  }

  async trackSession(sessionId: string, data: any): Promise<void> {
    this.logger.log(`Tracking WeChat session: ${sessionId}`, data);
  }

  /**
   * ç”Ÿæˆå¾®ä¿¡å°ç¨‹åºäºŒç»´ç 
   */
  async generateQRCode(game: Game, sessionId: string): Promise<Buffer> {
    try {
      const accessToken = await this.getAccessToken();
      const config = game.platformConfig;

      const response = await firstValueFrom(
        this.httpService.post(
          `https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${accessToken}`,
          {
            scene: `sid=${sessionId}`,
            page: config?.wechat_path || 'pages/index/index',
            check_path: false,
            env_version: config?.wechat_version || 'release',
            width: 430,
          },
          {
            responseType: 'arraybuffer',
          }
        )
      );

      return Buffer.from(response.data);
    } catch (error) {
      this.logger.error('Failed to generate WeChat QR code:', error);
      throw error;
    }
  }

  /**
   * è·å–å¾®ä¿¡ access_token
   */
  private async getAccessToken(): Promise<string> {
    // æ£€æŸ¥ç¼“å­˜çš„ token æ˜¯å¦æœ‰æ•ˆ
    if (this.accessToken && Date.now() < this.tokenExpireTime) {
      return this.accessToken;
    }

    const appId = this.configService.get('WECHAT_APP_ID');
    const secret = this.configService.get('WECHAT_APP_SECRET');

    const response = await firstValueFrom(
      this.httpService.get(
        'https://api.weixin.qq.com/cgi-bin/token',
        {
          params: {
            grant_type: 'client_credential',
            appid: appId,
            secret: secret,
          },
        }
      )
    );

    if (response.data.errcode) {
      throw new Error(`WeChat API error: ${response.data.errmsg}`);
    }

    this.accessToken = response.data.access_token;
    // æå‰ 5 åˆ†é’Ÿè¿‡æœŸ
    this.tokenExpireTime = Date.now() + (response.data.expires_in - 300) * 1000;

    return this.accessToken;
  }
}
```

#### æ­¥éª¤ 2.4: å®ç°æŠ–éŸ³å°æ¸¸æˆé€‚é…å™¨

**æ–‡ä»¶**: `backend/src/modules/games/services/platform-adapters/douyin.adapter.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { BasePlatformAdapter, GameLaunchParams, GameLaunchResult } from './base.adapter';
import { Game, PlatformConfig } from '../../entities/game.entity';

@Injectable()
export class DouyinAdapter extends BasePlatformAdapter {
  private readonly logger = new Logger(DouyinAdapter.name);

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
  ) {
    super();
  }

  validateConfig(config: PlatformConfig): boolean {
    return !!(config?.douyin_app_id && config?.douyin_path);
  }

  async prepareLaunch(
    game: Game,
    params: GameLaunchParams
  ): Promise<GameLaunchResult> {
    const config = game.platformConfig;
    
    if (!this.validateConfig(config)) {
      return {
        success: false,
        error: 'Douyin mini-game configuration incomplete',
      };
    }

    // ç”Ÿæˆå¯åŠ¨å‚æ•°
    const launchParams = {
      session_id: params.sessionId,
      user_id: params.userId,
      game_id: params.gameId,
    };

    const query = encodeURIComponent(JSON.stringify(launchParams));

    // æŠ–éŸ³å°æ¸¸æˆ URL Scheme
    // æ ¼å¼: snssdk1128://microapp?app_id=<appid>&start_page=<path>&params=<query>
    const launchUrl = `snssdk1128://microapp?app_id=${config.douyin_app_id}&start_page=${config.douyin_path}&params=${query}`;

    return {
      success: true,
      launchUrl,
      launchData: {
        type: 'douyin_mini_game',
        appId: config.douyin_app_id,
        path: config.douyin_path,
        query: launchParams,
      },
    };
  }

  async trackSession(sessionId: string, data: any): Promise<void> {
    this.logger.log(`Tracking Douyin session: ${sessionId}`, data);
  }
}
```

#### æ­¥éª¤ 2.5: åˆ›å»ºæ¸¸æˆå¹³å°æœåŠ¡

**æ–‡ä»¶**: `backend/src/modules/games/services/game-platform.service.ts`

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { GamePlatform } from '../entities/game.entity';
import { Html5Adapter } from './platform-adapters/html5.adapter';
import { WechatAdapter } from './platform-adapters/wechat.adapter';
import { DouyinAdapter } from './platform-adapters/douyin.adapter';
import { BasePlatformAdapter, GameLaunchParams, GameLaunchResult } from './platform-adapters/base.adapter';
import { Game } from '../entities/game.entity';

@Injectable()
export class GamePlatformService {
  private readonly logger = new Logger(GamePlatformService.name);
  private adapters: Map<GamePlatform, BasePlatformAdapter>;

  constructor(
    private readonly html5Adapter: Html5Adapter,
    private readonly wechatAdapter: WechatAdapter,
    private readonly douyinAdapter: DouyinAdapter,
  ) {
    this.adapters = new Map([
      [GamePlatform.HTML5, html5Adapter],
      [GamePlatform.WECHAT, wechatAdapter],
      [GamePlatform.DOUYIN, douyinAdapter],
    ]);
  }

  /**
   * å‡†å¤‡æ¸¸æˆå¯åŠ¨
   */
  async prepareLaunch(
    game: Game,
    params: GameLaunchParams
  ): Promise<GameLaunchResult> {
    const adapter = this.adapters.get(game.platform);
    
    if (!adapter) {
      return {
        success: false,
        error: `Platform ${game.platform} not supported`,
      };
    }

    // éªŒè¯å¹³å°é…ç½®
    if (!adapter.validateConfig(game.platformConfig || {})) {
      return {
        success: false,
        error: `Invalid configuration for platform ${game.platform}`,
      };
    }

    try {
      const result = await adapter.prepareLaunch(game, params);
      this.logger.log(`Game launch prepared: ${game.id}, platform: ${game.platform}`);
      return result;
    } catch (error) {
      this.logger.error(`Failed to prepare launch for ${game.id}:`, error);
      return {
        success: false,
        error: error.message || 'Failed to prepare game launch',
      };
    }
  }

  /**
   * æ£€æµ‹ç”¨æˆ·å½“å‰å¹³å°ç¯å¢ƒ
   */
  detectPlatform(userAgent: string): GamePlatform {
    const ua = userAgent.toLowerCase();
    
    if (ua.includes('micromessenger')) {
      return GamePlatform.WECHAT;
    }
    
    if (ua.includes('aweme') || ua.includes('douyin')) {
      return GamePlatform.DOUYIN;
    }
    
    return GamePlatform.HTML5;
  }

  /**
   * è·å–æ¸¸æˆæ”¯æŒçš„å¹³å°åˆ—è¡¨
   */
  getSupportedPlatforms(game: Game): GamePlatform[] {
    return game.supportedPlatforms || [game.platform];
  }

  /**
   * ç”Ÿæˆæ¸¸æˆäºŒç»´ç 
   */
  async generateQRCode(game: Game, sessionId: string): Promise<Buffer> {
    const adapter = this.adapters.get(game.platform);
    
    if (!adapter || !adapter.generateQRCode) {
      throw new Error(`QR code generation not supported for platform ${game.platform}`);
    }

    return adapter.generateQRCode(game, sessionId);
  }

  /**
   * è·Ÿè¸ªæ¸¸æˆä¼šè¯
   */
  async trackSession(
    game: Game,
    sessionId: string,
    data: any
  ): Promise<void> {
    const adapter = this.adapters.get(game.platform);
    
    if (!adapter) {
      this.logger.warn(`No adapter found for platform ${game.platform}`);
      return;
    }

    await adapter.trackSession(sessionId, data);
  }
}
```

#### æ­¥éª¤ 2.6: æ›´æ–° GamesModule

**æ–‡ä»¶**: `backend/src/modules/games/games.module.ts`

**æ·»åŠ çš„ä»£ç **:

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { HttpModule } from '@nestjs/axios';
import { Game } from './entities/game.entity';
import { GameSession } from './entities/game-session.entity';
import { GamesService } from './services/games.service';
import { GamesController } from './controllers/games.controller';

// å¯¼å…¥å¹³å°é€‚é…å™¨
import { Html5Adapter } from './services/platform-adapters/html5.adapter';
import { WechatAdapter } from './services/platform-adapters/wechat.adapter';
import { DouyinAdapter } from './services/platform-adapters/douyin.adapter';
import { GamePlatformService } from './services/game-platform.service';

@Module({
  imports: [
    TypeOrmModule.forFeature([Game, GameSession]),
    HttpModule, // ç”¨äº OAuth å’Œå¹³å° API è°ƒç”¨
  ],
  providers: [
    GamesService,
    // å¹³å°é€‚é…å™¨
    Html5Adapter,
    WechatAdapter,
    DouyinAdapter,
    GamePlatformService,
  ],
  controllers: [GamesController],
  exports: [GamesService, GamePlatformService],
})
export class GamesModule {}
```

#### æ­¥éª¤ 2.7: æ›´æ–°æ¸¸æˆæ§åˆ¶å™¨

**æ–‡ä»¶**: `backend/src/modules/games/controllers/games.controller.ts`

**æ·»åŠ æ–°çš„ç«¯ç‚¹**:

```typescript
import { Controller, Post, Get, Param, Body, Headers, Res } from '@nestjs/common';
import { Response } from 'express';
import { GamePlatformService } from '../services/game-platform.service';
import { GamesService } from '../services/games.service';

@Controller('games')
export class GamesController {
  constructor(
    private readonly gamesService: GamesService,
    private readonly gamePlatformService: GamePlatformService,
  ) {}

  /**
   * å‡†å¤‡æ¸¸æˆå¯åŠ¨
   * POST /games/:id/launch
   */
  @Post(':id/launch')
  async launchGame(
    @Param('id') gameId: string,
    @Body() body: { session_id: string; user_id: string },
    @Headers('user-agent') userAgent: string,
  ) {
    const game = await this.gamesService.findOne(gameId);
    
    if (!game) {
      throw new Error('Game not found');
    }

    const result = await this.gamePlatformService.prepareLaunch(game, {
      gameId,
      userId: body.user_id,
      sessionId: body.session_id,
      platform: game.platform,
      userAgent,
    });

    return {
      success: result.success,
      launchUrl: result.launchUrl,
      launchData: result.launchData,
      error: result.error,
    };
  }

  /**
   * è·å–æ¸¸æˆäºŒç»´ç 
   * GET /games/:id/qrcode
   */
  @Get(':id/qrcode')
  async getGameQRCode(
    @Param('id') gameId: string,
    @Query('session_id') sessionId: string,
    @Res() res: Response,
  ) {
    const game = await this.gamesService.findOne(gameId);
    
    if (!game) {
      throw new Error('Game not found');
    }

    try {
      const qrCode = await this.gamePlatformService.generateQRCode(game, sessionId);
      
      res.setHeader('Content-Type', 'image/png');
      res.send(qrCode);
    } catch (error) {
      throw new Error('Failed to generate QR code');
    }
  }

  /**
   * æ£€æµ‹å¹³å°
   * GET /games/detect-platform
   */
  @Get('detect-platform')
  detectPlatform(@Headers('user-agent') userAgent: string) {
    const platform = this.gamePlatformService.detectPlatform(userAgent);
    
    return {
      platform,
      userAgent,
    };
  }
}
```

---

### Phase 3: å‰ç«¯å¹³å°æ”¯æŒå®ç° (1å‘¨)

#### æ­¥éª¤ 3.1: åˆ›å»ºå¹³å°æ£€æµ‹å·¥å…·

**æ–‡ä»¶**: `frontend/src/utils/platform-detector.ts`

```typescript
export enum PlatformType {
  HTML5 = 'html5',
  WECHAT = 'wechat',
  DOUYIN = 'douyin',
  MOBILE_APP = 'mobile_app',
}

export interface PlatformInfo {
  type: PlatformType;
  isWechat: boolean;
  isDouyin: boolean;
  isMobile: boolean;
  isIOS: boolean;
  isAndroid: boolean;
  isWeixin: boolean;
  isQQ: boolean;
}

/**
 * æ£€æµ‹å½“å‰è¿è¡Œå¹³å°
 */
export function detectPlatform(): PlatformInfo {
  const ua = navigator.userAgent.toLowerCase();
  
  const isWechat = /micromessenger/.test(ua);
  const isDouyin = /aweme|douyin/.test(ua);
  const isMobile = /mobile|android|iphone|ipad|ipod/.test(ua);
  const isIOS = /iphone|ipad|ipod/.test(ua);
  const isAndroid = /android/.test(ua);
  const isWeixin = isWechat;
  const isQQ = /qq\//.test(ua);

  let type: PlatformType;
  if (isWechat) {
    type = PlatformType.WECHAT;
  } else if (isDouyin) {
    type = PlatformType.DOUYIN;
  } else {
    type = PlatformType.HTML5;
  }

  return {
    type,
    isWechat,
    isDouyin,
    isMobile,
    isIOS,
    isAndroid,
    isWeixin,
    isQQ,
  };
}

/**
 * åˆ¤æ–­æ˜¯å¦æ”¯æŒæŸä¸ªå¹³å°
 */
export function isPlatformSupported(
  gamePlatform: string,
  currentPlatform: PlatformInfo
): boolean {
  switch (gamePlatform) {
    case 'html5':
      return true; // HTML5 æ‰€æœ‰å¹³å°éƒ½æ”¯æŒ
    case 'wechat':
      return currentPlatform.isWechat;
    case 'douyin':
      return currentPlatform.isDouyin;
    default:
      return false;
  }
}

/**
 * è·å–å¹³å°æ˜¾ç¤ºåç§°
 */
export function getPlatformName(platform: string): string {
  const names: Record<string, string> = {
    html5: 'HTML5 æ¸¸æˆ',
    wechat: 'å¾®ä¿¡å°æ¸¸æˆ',
    douyin: 'æŠ–éŸ³å°æ¸¸æˆ',
    native: 'åŸç”Ÿæ¸¸æˆ',
  };
  return names[platform] || platform;
}

/**
 * è·å–å¹³å°å›¾æ ‡
 */
export function getPlatformIcon(platform: string): string {
  const icons: Record<string, string> = {
    html5: 'ğŸŒ',
    wechat: 'ğŸ’¬',
    douyin: 'ğŸµ',
    native: 'ğŸ“±',
  };
  return icons[platform] || 'ğŸ®';
}
```

#### æ­¥éª¤ 3.2: åˆ›å»º HTML5 æ¸¸æˆæ’­æ”¾å™¨ç»„ä»¶

**æ–‡ä»¶**: `frontend/src/components/business/Html5GamePlayer.tsx`

```typescript
import React, { useRef, useEffect, useState } from 'react';
import { Alert, Spin } from 'antd';

interface Html5GamePlayerProps {
  game: any; // Game ç±»å‹
  sessionId: string;
  onLoad?: () => void;
  onError?: (error: Error) => void;
}

export const Html5GamePlayer: React.FC<Html5GamePlayerProps> = ({
  game,
  sessionId,
  onLoad,
  onError,
}) => {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // è®¾ç½® postMessage é€šä¿¡ç›‘å¬
    const handleMessage = (event: MessageEvent) => {
      // éªŒè¯æ¶ˆæ¯æ¥æº
      try {
        const gameOrigin = new URL(game.game_url).origin;
        if (event.origin !== gameOrigin) {
          console.warn('Message from untrusted origin:', event.origin);
          return;
        }
      } catch (err) {
        console.error('Invalid game URL:', err);
        return;
      }

      // å¤„ç†æ¸¸æˆæ¶ˆæ¯
      switch (event.data.type) {
        case 'game_ready':
          console.log('Game loaded successfully');
          setLoading(false);
          onLoad?.();
          break;
        
        case 'game_score':
          console.log('Game score update:', event.data.score);
          // å¯ä»¥å‘é€åˆ°åç«¯ä¿å­˜åˆ†æ•°
          break;
        
        case 'game_complete':
          console.log('Game completed');
          // å¯ä»¥è§¦å‘ä¼šè¯ç»“æŸ
          break;
        
        case 'game_error':
          console.error('Game error:', event.data.error);
          setError(event.data.error);
          onError?.(new Error(event.data.error));
          break;
      }
    };

    window.addEventListener('message', handleMessage);

    // è®¾ç½®åŠ è½½è¶…æ—¶
    const loadTimeout = setTimeout(() => {
      if (loading) {
        setLoading(false);
        console.log('Game load timeout, assuming loaded');
        onLoad?.();
      }
    }, 10000); // 10ç§’è¶…æ—¶

    return () => {
      window.removeEventListener('message', handleMessage);
      clearTimeout(loadTimeout);
    };
  }, [game.game_url, loading, onLoad, onError]);

  const handleIframeLoad = () => {
    // iframe åŠ è½½å®Œæˆ
    setLoading(false);
    onLoad?.();
    
    // å‘æ¸¸æˆå‘é€åˆå§‹åŒ–æ¶ˆæ¯
    if (iframeRef.current?.contentWindow) {
      iframeRef.current.contentWindow.postMessage(
        {
          type: 'init',
          sessionId,
          gameId: game.id,
        },
        '*'
      );
    }
  };

  const handleIframeError = () => {
    setError('æ¸¸æˆåŠ è½½å¤±è´¥');
    setLoading(false);
    onError?.(new Error('Failed to load game iframe'));
  };

  const sandbox = game.platform_config?.sandbox_permissions?.join(' ') || 
    'allow-scripts allow-same-origin allow-popups allow-forms';

  const gameUrl = `${game.game_url}?session_id=${sessionId}&game_id=${game.id}`;

  if (error) {
    return (
      <Alert
        message="æ¸¸æˆåŠ è½½å¤±è´¥"
        description={error}
        type="error"
        showIcon
      />
    );
  }

  return (
    <div className="html5-game-player" style={{ position: 'relative', width: '100%', height: '100%' }}>
      {loading && (
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            zIndex: 10,
          }}
        >
          <Spin size="large" />
          <span style={{ marginLeft: 16, color: 'white' }}>åŠ è½½æ¸¸æˆä¸­...</span>
        </div>
      )}
      
      <iframe
        ref={iframeRef}
        src={gameUrl}
        sandbox={sandbox}
        onLoad={handleIframeLoad}
        onError={handleIframeError}
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"
        style={{
          width: '100%',
          height: '100%',
          border: 'none',
          display: 'block',
        }}
        title={game.title}
      />
    </div>
  );
};
```

#### æ­¥éª¤ 3.3: åˆ›å»ºå¾®ä¿¡å°æ¸¸æˆå¯åŠ¨å™¨

**æ–‡ä»¶**: `frontend/src/components/business/WechatGameLauncher.tsx`

```typescript
import React, { useEffect, useState } from 'react';
import { Button, Alert, Card, QRCode, Tabs, message } from 'antd';
import { WechatOutlined, QrcodeOutlined } from '@ant-design/icons';
import { detectPlatform } from '@/utils/platform-detector';

declare const wx: any; // å¾®ä¿¡ JSSDK

interface WechatGameLauncherProps {
  game: any;
  sessionId: string;
}

export const WechatGameLauncher: React.FC<WechatGameLauncherProps> = ({
  game,
  sessionId,
}) => {
  const [launching, setLaunching] = useState(false);
  const [platform] = useState(() => detectPlatform());

  const handleLaunch = async () => {
    setLaunching(true);
    
    try {
      // è°ƒç”¨åç«¯è·å–å¯åŠ¨æ•°æ®
      const response = await fetch(`/api/games/${game.id}/launch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: sessionId,
          user_id: 'current_user_id', // ä»è®¤è¯çŠ¶æ€è·å–
        }),
      });
      
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'å¯åŠ¨å¤±è´¥');
      }

      const { launchData } = result;

      // ä½¿ç”¨å¾®ä¿¡ SDK å¯åŠ¨å°æ¸¸æˆ
      if (typeof wx !== 'undefined' && wx.miniProgram) {
        wx.miniProgram.navigateToMiniProgram({
          appId: launchData.appId,
          path: launchData.path,
          extraData: {
            session_id: sessionId,
          },
          envVersion: launchData.envVersion,
          success: () => {
            message.success('å¯åŠ¨æˆåŠŸ');
          },
          fail: (err: any) => {
            console.error('Launch failed:', err);
            message.error('å¯åŠ¨å¤±è´¥ï¼š' + err.errMsg);
          },
        });
      } else {
        message.error('è¯·åœ¨å¾®ä¿¡ä¸­æ‰“å¼€');
      }
    } catch (error: any) {
      console.error(error);
      message.error(error.message || 'å¯åŠ¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    } finally {
      setLaunching(false);
    }
  };

  // å¦‚æœåœ¨å¾®ä¿¡ç¯å¢ƒä¸­ï¼Œæ˜¾ç¤ºå¯åŠ¨æŒ‰é’®
  if (platform.isWechat) {
    return (
      <Card className="wechat-game-launcher">
        <Alert
          message="å¾®ä¿¡å°æ¸¸æˆ"
          description="ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨æ¸¸æˆ"
          type="info"
          showIcon
          icon={<WechatOutlined />}
          style={{ marginBottom: 16 }}
        />
        <Button
          type="primary"
          size="large"
          icon={<WechatOutlined />}
          loading={launching}
          onClick={handleLaunch}
          block
          style={{ backgroundColor: '#07c160' }}
        >
          å¯åŠ¨æ¸¸æˆ
        </Button>
      </Card>
    );
  }

  // éå¾®ä¿¡ç¯å¢ƒï¼Œæ˜¾ç¤ºäºŒç»´ç 
  return <WechatGameQRCode game={game} sessionId={sessionId} />;
};

// éå¾®ä¿¡ç¯å¢ƒæ˜¾ç¤ºäºŒç»´ç ç»„ä»¶
export const WechatGameQRCode: React.FC<WechatGameLauncherProps> = ({
  game,
  sessionId,
}) => {
  const [qrCodeUrl, setQrCodeUrl] = useState('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // è·å–äºŒç»´ç 
    const fetchQRCode = async () => {
      try {
        const response = await fetch(
          `/api/games/${game.id}/qrcode?session_id=${sessionId}&platform=wechat`
        );
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        setQrCodeUrl(url);
      } catch (error) {
        console.error('Failed to fetch QR code:', error);
        message.error('è·å–äºŒç»´ç å¤±è´¥');
      } finally {
        setLoading(false);
      }
    };

    fetchQRCode();

    return () => {
      if (qrCodeUrl) {
        URL.revokeObjectURL(qrCodeUrl);
      }
    };
  }, [game.id, sessionId]);

  return (
    <Card className="text-center">
      <Alert
        message="è¯·ä½¿ç”¨å¾®ä¿¡æ‰«ç è¿›å…¥æ¸¸æˆ"
        type="info"
        showIcon
        icon={<QrcodeOutlined />}
        style={{ marginBottom: 24 }}
      />
      
      {loading ? (
        <div>åŠ è½½äºŒç»´ç ä¸­...</div>
      ) : qrCodeUrl ? (
        <img
          src={qrCodeUrl}
          alt="å¾®ä¿¡å°æ¸¸æˆäºŒç»´ç "
          style={{ width: 250, height: 250, margin: '0 auto' }}
        />
      ) : (
        <div>è·å–äºŒç»´ç å¤±è´¥</div>
      )}
      
      <p style={{ marginTop: 16, color: '#666' }}>
        ä½¿ç”¨å¾®ä¿¡æ‰«ä¸€æ‰«ï¼Œå³å¯å¼€å§‹æ¸¸æˆ
      </p>
    </Card>
  );
};
```

#### æ­¥éª¤ 3.4: åˆ›å»ºæŠ–éŸ³å°æ¸¸æˆå¯åŠ¨å™¨

**æ–‡ä»¶**: `frontend/src/components/business/DouyinGameLauncher.tsx`

```typescript
import React, { useState } from 'react';
import { Button, Alert, Card, message } from 'antd';
import { detectPlatform } from '@/utils/platform-detector';

declare const tt: any; // æŠ–éŸ³å°ç¨‹åº SDK

interface DouyinGameLauncherProps {
  game: any;
  sessionId: string;
}

export const DouyinGameLauncher: React.FC<DouyinGameLauncherProps> = ({
  game,
  sessionId,
}) => {
  const [launching, setLaunching] = useState(false);
  const [platform] = useState(() => detectPlatform());

  const handleLaunch = async () => {
    setLaunching(true);
    
    try {
      const response = await fetch(`/api/games/${game.id}/launch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: sessionId,
          user_id: 'current_user_id',
        }),
      });
      
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'å¯åŠ¨å¤±è´¥');
      }

      const { launchData } = result;

      // ä½¿ç”¨æŠ–éŸ³ SDK å¯åŠ¨å°æ¸¸æˆ
      if (typeof tt !== 'undefined' && tt.navigateToMicroApp) {
        tt.navigateToMicroApp({
          appId: launchData.appId,
          path: launchData.path,
          extraData: {
            session_id: sessionId,
          },
          success: () => {
            message.success('å¯åŠ¨æˆåŠŸ');
          },
          fail: (err: any) => {
            console.error('Launch failed:', err);
            message.error('å¯åŠ¨å¤±è´¥ï¼š' + err.errMsg);
          },
        });
      } else {
        // å°è¯•ä½¿ç”¨ URL Scheme
        window.location.href = result.launchUrl;
      }
    } catch (error: any) {
      console.error(error);
      message.error(error.message || 'å¯åŠ¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    } finally {
      setLaunching(false);
    }
  };

  if (platform.isDouyin) {
    return (
      <Card className="douyin-game-launcher">
        <Alert
          message="æŠ–éŸ³å°æ¸¸æˆ"
          description="ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨æ¸¸æˆ"
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
        />
        <Button
          type="primary"
          size="large"
          loading={launching}
          onClick={handleLaunch}
          block
        >
          å¯åŠ¨æ¸¸æˆ
        </Button>
      </Card>
    );
  }

  return (
    <Card className="text-center">
      <Alert
        message="è¯·åœ¨æŠ–éŸ³ä¸­æ‰“å¼€"
        description="æ­¤æ¸¸æˆä»…æ”¯æŒåœ¨æŠ–éŸ³APPä¸­æ¸¸ç©"
        type="warning"
        showIcon
        style={{ marginBottom: 16 }}
      />
      <p style={{ color: '#666' }}>
        è¯·å¤åˆ¶é“¾æ¥åˆ°æŠ–éŸ³APPä¸­æ‰“å¼€
      </p>
    </Card>
  );
};
```

#### æ­¥éª¤ 3.5: åˆ›å»ºæ¸¸æˆåŠ è½½å™¨ç»„ä»¶ï¼ˆç»Ÿä¸€å…¥å£ï¼‰

**æ–‡ä»¶**: `frontend/src/components/business/GameLoader.tsx`

```typescript
import React, { useState } from 'react';
import { Alert, Tabs } from 'antd';
import { detectPlatform, isPlatformSupported, getPlatformName } from '@/utils/platform-detector';
import { Html5GamePlayer } from './Html5GamePlayer';
import { WechatGameLauncher } from './WechatGameLauncher';
import { DouyinGameLauncher } from './DouyinGameLauncher';

interface GameLoaderProps {
  game: any;
  sessionId: string;
  onLoad?: () => void;
  onError?: (error: Error) => void;
}

/**
 * æ¸¸æˆåŠ è½½å™¨ - æ ¹æ®æ¸¸æˆå¹³å°å’Œå½“å‰ç¯å¢ƒé€‰æ‹©åˆé€‚çš„åŠ è½½æ–¹å¼
 */
export const GameLoader: React.FC<GameLoaderProps> = ({
  game,
  sessionId,
  onLoad,
  onError,
}) => {
  const [currentPlatform] = useState(() => detectPlatform());
  const [selectedPlatform, setSelectedPlatform] = useState(game.platform);

  // æ¸²æŸ“å¯¹åº”å¹³å°çš„åŠ è½½å™¨
  const renderLoader = (platform: string) => {
    switch (platform) {
      case 'html5':
        return (
          <Html5GamePlayer
            game={game}
            sessionId={sessionId}
            onLoad={onLoad}
            onError={onError}
          />
        );
      
      case 'wechat':
        return (
          <WechatGameLauncher
            game={game}
            sessionId={sessionId}
          />
        );
      
      case 'douyin':
        return (
          <DouyinGameLauncher
            game={game}
            sessionId={sessionId}
          />
        );
      
      default:
        return (
          <Alert
            message="ä¸æ”¯æŒçš„æ¸¸æˆå¹³å°"
            description={`æ¸¸æˆå¹³å° ${platform} æš‚ä¸æ”¯æŒ`}
            type="error"
            showIcon
          />
        );
    }
  };

  // å¦‚æœæ¸¸æˆæ”¯æŒå¤šä¸ªå¹³å°ï¼Œæ˜¾ç¤ºæ ‡ç­¾é¡µåˆ‡æ¢
  const supportedPlatforms = game.supported_platforms || [game.platform];
  
  if (supportedPlatforms.length > 1) {
    const tabItems = supportedPlatforms.map((platform: string) => ({
      key: platform,
      label: getPlatformName(platform),
      children: renderLoader(platform),
      disabled: !isPlatformSupported(platform, currentPlatform),
    }));

    return (
      <div className="game-loader">
        <Tabs
          activeKey={selectedPlatform}
          onChange={setSelectedPlatform}
          items={tabItems}
        />
      </div>
    );
  }

  // å•å¹³å°æ¸¸æˆï¼Œç›´æ¥æ¸²æŸ“
  return (
    <div className="game-loader">
      {renderLoader(game.platform)}
    </div>
  );
};
```

#### æ­¥éª¤ 3.6: é›†æˆåˆ°æ¸¸æˆæ’­æ”¾é¡µé¢

**æ–‡ä»¶**: `frontend/src/pages/Game/GamePlayer.tsx`

**ä¿®æ”¹ç°æœ‰çš„ GamePlayer ç»„ä»¶**:

```typescript
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button, Card, message } from 'antd';
import { CloseOutlined } from '@ant-design/icons';
import { getGameById } from '@/services/api/games';
import { GameLoader } from '@/components/business/GameLoader';
import Loading from '@/components/common/Loading';

const GamePlayer: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();

  const [game, setGame] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [sessionId] = useState(() => {
    // ä» localStorage è·å–æˆ–ç”Ÿæˆæ–°çš„ session ID
    const stored = localStorage.getItem(`game_session_${id}`);
    return stored || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  });

  useEffect(() => {
    const fetchGame = async () => {
      if (!id) {
        setError('æ¸¸æˆ ID æ— æ•ˆ');
        setLoading(false);
        return;
      }

      try {
        const gameData = await getGameById(id);
        setGame(gameData);
        
        // ä¿å­˜ session ID
        localStorage.setItem(`game_session_${id}`, sessionId);
      } catch (err: any) {
        console.error('Failed to fetch game:', err);
        setError(err.message || 'åŠ è½½æ¸¸æˆå¤±è´¥');
      } finally {
        setLoading(false);
      }
    };

    fetchGame();

    // æ¸…ç†å‡½æ•°
    return () => {
      // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†ä¼šè¯ç»“æŸé€»è¾‘
    };
  }, [id, sessionId]);

  const handleExit = () => {
    // æ¸…ç† session
    localStorage.removeItem(`game_session_${id}`);
    navigate(`/games/${id}`);
  };

  const handleGameLoad = () => {
    console.log('Game loaded successfully');
  };

  const handleGameError = (error: Error) => {
    message.error('æ¸¸æˆåŠ è½½å¤±è´¥ï¼š' + error.message);
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loading message="åŠ è½½æ¸¸æˆä¸­..." />
      </div>
    );
  }

  if (error || !game) {
    return (
      <div className="container mx-auto p-4">
        <Card>
          <p className="text-red-500">{error || 'æ¸¸æˆä¸å­˜åœ¨'}</p>
          <Button onClick={() => navigate('/games')}>è¿”å›æ¸¸æˆåˆ—è¡¨</Button>
        </Card>
      </div>
    );
  }

  return (
    <div className="game-player-page" style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* é¡¶éƒ¨å·¥å…·æ  */}
      <div className="game-toolbar" style={{ padding: '8px 16px', backgroundColor: '#001529', color: 'white', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <div>
          <strong>{game.title}</strong>
        </div>
        <Button
          type="text"
          icon={<CloseOutlined />}
          onClick={handleExit}
          style={{ color: 'white' }}
        >
          é€€å‡ºæ¸¸æˆ
        </Button>
      </div>

      {/* æ¸¸æˆåŠ è½½åŒºåŸŸ */}
      <div className="game-container" style={{ flex: 1, overflow: 'hidden' }}>
        <GameLoader
          game={game}
          sessionId={sessionId}
          onLoad={handleGameLoad}
          onError={handleGameError}
        />
      </div>
    </div>
  );
};

export default GamePlayer;
```

---

### Phase 4: æµ‹è¯•ä¸ä¼˜åŒ– (3å¤©)

#### æµ‹è¯•æ¸…å•

**å•å…ƒæµ‹è¯•**:
```bash
# åç«¯
cd backend
npm test -- platform-adapters
npm test -- game-platform.service

# å‰ç«¯
cd frontend
npm test -- platform-detector
npm test -- GameLoader
```

**é›†æˆæµ‹è¯•**:
- [ ] HTML5 æ¸¸æˆåŠ è½½æµ‹è¯•
- [ ] å¾®ä¿¡å°æ¸¸æˆå¯åŠ¨æµ‹è¯•
- [ ] æŠ–éŸ³å°æ¸¸æˆå¯åŠ¨æµ‹è¯•
- [ ] äºŒç»´ç ç”Ÿæˆæµ‹è¯•
- [ ] å¹³å°åˆ‡æ¢æµ‹è¯•

**å…¼å®¹æ€§æµ‹è¯•**:
- [ ] Chrome æµè§ˆå™¨
- [ ] Safari æµè§ˆå™¨
- [ ] å¾®ä¿¡å†…ç½®æµè§ˆå™¨
- [ ] æŠ–éŸ³APP
- [ ] iOS è®¾å¤‡
- [ ] Android è®¾å¤‡

---

## ğŸ” éœ€æ±‚äºŒï¼šå¤šå¹³å°ç¬¬ä¸‰æ–¹ç™»å½•

### Phase 5: åç«¯ OAuth å®ç° (1å‘¨)

#### æ­¥éª¤ 5.1: æ‰©å±•è®¤è¯ç±»å‹æšä¸¾

**æ–‡ä»¶**: `backend/src/modules/auth/entities/user-auth-method.entity.ts`

**ä¿®æ”¹ AuthType æšä¸¾**:

```typescript
export enum AuthType {
  PHONE = 'phone',
  EMAIL = 'email',
  WECHAT = 'wechat',
  QQ = 'qq',
  APPLE = 'apple',
  ALIPAY = 'alipay',      // æ–°å¢ï¼šæ”¯ä»˜å®
  WEIBO = 'weibo',        // æ–°å¢ï¼šå¾®åš
  DOUYIN = 'douyin',      // æ–°å¢ï¼šæŠ–éŸ³
  GOOGLE = 'google',      // æ–°å¢ï¼šGoogle
}
```

#### æ­¥éª¤ 5.2: åˆ›å»ºæ•°æ®åº“è¿ç§»

**æ–‡ä»¶**: `backend/src/database/migrations/011_extend_auth_types.ts`

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class ExtendAuthTypes1700000000000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // å¦‚æœä½¿ç”¨ enum ç±»å‹ï¼Œéœ€è¦æ›´æ–°
    await queryRunner.query(`
      ALTER TYPE "user_auth_methods_auth_type_enum" 
      ADD VALUE IF NOT EXISTS 'alipay'
    `);
    
    await queryRunner.query(`
      ALTER TYPE "user_auth_methods_auth_type_enum" 
      ADD VALUE IF NOT EXISTS 'weibo'
    `);
    
    await queryRunner.query(`
      ALTER TYPE "user_auth_methods_auth_type_enum" 
      ADD VALUE IF NOT EXISTS 'douyin'
    `);
    
    await queryRunner.query(`
      ALTER TYPE "user_auth_methods_auth_type_enum" 
      ADD VALUE IF NOT EXISTS 'google'
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // PostgreSQL ä¸æ”¯æŒåˆ é™¤ enum å€¼
    // å¦‚æœéœ€è¦å›æ»šï¼Œéœ€è¦é‡æ–°åˆ›å»º enum ç±»å‹
  }
}
```

#### æ­¥éª¤ 5.3: åˆ›å»º OAuth æ¥å£å®šä¹‰

**æ–‡ä»¶**: `backend/src/modules/auth/interfaces/oauth-provider.interface.ts`

```typescript
export interface OAuthConfig {
  clientId: string;
  clientSecret: string;
  redirectUri: string;
  scope: string[];
  authorizationUrl: string;
  tokenUrl: string;
  userInfoUrl: string;
}

export interface OAuthUserInfo {
  providerId: string;      // ç¬¬ä¸‰æ–¹å¹³å°çš„ç”¨æˆ·ID
  nickname?: string;
  avatar?: string;
  email?: string;
  phone?: string;
  gender?: 'male' | 'female' | 'unknown';
  unionId?: string;        // ç”¨äºè·¨åº”ç”¨è¯†åˆ«
  rawData: any;            // åŸå§‹æ•°æ®
}

export interface OAuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
  scope?: string;
}

export interface IOAuthProvider {
  /**
   * è·å–æˆæƒURL
   */
  getAuthorizationUrl(state: string): string;

  /**
   * ç”¨æˆæƒç äº¤æ¢è®¿é—®ä»¤ç‰Œ
   */
  exchangeCode(code: string): Promise<OAuthTokens>;

  /**
   * è·å–ç”¨æˆ·ä¿¡æ¯
   */
  getUserInfo(accessToken: string): Promise<OAuthUserInfo>;

  /**
   * éªŒè¯è®¿é—®ä»¤ç‰Œæ˜¯å¦æœ‰æ•ˆ
   */
  validateToken(accessToken: string): Promise<boolean>;

  /**
   * åˆ·æ–°è®¿é—®ä»¤ç‰Œï¼ˆå¯é€‰ï¼‰
   */
  refreshToken?(refreshToken: string): Promise<OAuthTokens>;
}
```

#### æ­¥éª¤ 5.4: å®ç°å„å¹³å° OAuth Provider

ç”±äºä»£ç è¾ƒé•¿ï¼Œæˆ‘ä¼šåˆ›å»ºä¸€ä¸ªæ€»ç»“æ–‡æ¡£åˆ—å‡ºæ‰€æœ‰éœ€è¦å®ç°çš„æ–‡ä»¶ï¼š

**éœ€è¦åˆ›å»ºçš„ OAuth Provider æ–‡ä»¶**:

1. `backend/src/modules/auth/providers/wechat-oauth.provider.ts`
2. `backend/src/modules/auth/providers/qq-oauth.provider.ts`
3. `backend/src/modules/auth/providers/alipay-oauth.provider.ts` âœ¨æ–°å¢
4. `backend/src/modules/auth/providers/weibo-oauth.provider.ts` âœ¨æ–°å¢
5. `backend/src/modules/auth/providers/douyin-oauth.provider.ts` âœ¨æ–°å¢
6. `backend/src/modules/auth/providers/google-oauth.provider.ts` âœ¨æ–°å¢
7. `backend/src/modules/auth/providers/apple-oauth.provider.ts`

æ¯ä¸ª Provider çš„å®ç°ç»“æ„ç±»ä¼¼ï¼ŒåŒ…å«ï¼š
- é…ç½®åˆå§‹åŒ–
- `getAuthorizationUrl()` - ç”ŸæˆæˆæƒURL
- `exchangeCode()` - äº¤æ¢ access_token
- `getUserInfo()` - è·å–ç”¨æˆ·ä¿¡æ¯
- `validateToken()` - éªŒè¯tokenæœ‰æ•ˆæ€§

#### æ­¥éª¤ 5.5: åˆ›å»ºç»Ÿä¸€ OAuth æœåŠ¡

**æ–‡ä»¶**: `backend/src/modules/auth/services/oauth.service.ts`

è¿™ä¸ªæ–‡ä»¶çš„å®Œæ•´å®ç°è¯·å‚è€ƒä¹‹å‰æä¾›çš„è¯¦ç»†ä»£ç ã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š

- ç®¡ç†æ‰€æœ‰ OAuth Provider
- å¤„ç†OAuthå›è°ƒ
- åˆ›å»ºæˆ–å…³è”ç”¨æˆ·è´¦å·
- ç»‘å®š/è§£ç»‘ç¬¬ä¸‰æ–¹è´¦å·
- ç”ŸæˆJWT token

#### æ­¥éª¤ 5.6: åˆ›å»º OAuth æ§åˆ¶å™¨

**æ–‡ä»¶**: `backend/src/modules/auth/controllers/oauth.controller.ts`

```typescript
import { Controller, Get, Post, Query, Body, Param, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';
import { OAuthService } from '../services/oauth.service';
import { AuthType } from '../entities/user-auth-method.entity';

@Controller('auth/oauth')
export class OAuthController {
  constructor(private readonly oauthService: OAuthService) {}

  /**
   * è·å–OAuthæˆæƒURL
   * GET /auth/oauth/:provider/url
   */
  @Get(':provider/url')
  async getAuthUrl(
    @Param('provider') provider: string,
    @Query('state') state: string,
    @Query('redirect_uri') redirectUri?: string,
  ) {
    const authType = provider.toUpperCase() as AuthType;
    
    const url = await this.oauthService.getAuthorizationUrl(authType, state);
    
    return {
      url,
      provider: authType,
      state,
    };
  }

  /**
   * å¤„ç†OAuthå›è°ƒ
   * POST /auth/oauth/:provider/callback
   */
  @Post(':provider/callback')
  async handleCallback(
    @Param('provider') provider: string,
    @Body() body: { code: string; state: string },
    @Res() res: Response,
  ) {
    try {
      const authType = provider.toUpperCase() as AuthType;
      
      const result = await this.oauthService.handleCallback(
        authType,
        body.code,
        body.state,
      );

      return res.status(HttpStatus.OK).json({
        success: true,
        user: result.user,
        access_token: result.accessToken,
        refresh_token: result.refreshToken,
      });
    } catch (error) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        success: false,
        error: error.message,
      });
    }
  }

  /**
   * ç»‘å®šç¬¬ä¸‰æ–¹è´¦å·
   * POST /auth/oauth/:provider/bind
   */
  @Post(':provider/bind')
  async bindAccount(
    @Param('provider') provider: string,
    @Body() body: { code: string; user_id: string },
  ) {
    const authType = provider.toUpperCase() as AuthType;
    
    await this.oauthService.bindOAuthAccount(
      body.user_id,
      authType,
      body.code,
    );

    return {
      success: true,
      message: 'ç»‘å®šæˆåŠŸ',
    };
  }

  /**
   * è§£ç»‘ç¬¬ä¸‰æ–¹è´¦å·
   * DELETE /auth/oauth/:provider/unbind
   */
  @Delete(':provider/unbind')
  async unbindAccount(
    @Param('provider') provider: string,
    @Body() body: { user_id: string },
  ) {
    const authType = provider.toUpperCase() as AuthType;
    
    await this.oauthService.unbindOAuthAccount(body.user_id, authType);

    return {
      success: true,
      message: 'è§£ç»‘æˆåŠŸ',
    };
  }
}
```

#### æ­¥éª¤ 5.7: é…ç½®ç¯å¢ƒå˜é‡

**æ–‡ä»¶**: `backend/.env.example`

**æ·»åŠ OAuthé…ç½®**:

```bash
# å¾®ä¿¡ç™»å½•
WECHAT_APP_ID=your_wechat_app_id
WECHAT_APP_SECRET=your_wechat_app_secret
WECHAT_REDIRECT_URI=https://yourdomain.com/auth/callback/wechat

# QQç™»å½•
QQ_APP_ID=your_qq_app_id
QQ_APP_KEY=your_qq_app_key
QQ_REDIRECT_URI=https://yourdomain.com/auth/callback/qq

# æ”¯ä»˜å®ç™»å½•
ALIPAY_APP_ID=your_alipay_app_id
ALIPAY_PRIVATE_KEY=your_alipay_private_key
ALIPAY_PUBLIC_KEY=alipay_public_key
ALIPAY_REDIRECT_URI=https://yourdomain.com/auth/callback/alipay

# å¾®åšç™»å½•
WEIBO_APP_KEY=your_weibo_app_key
WEIBO_APP_SECRET=your_weibo_app_secret
WEIBO_REDIRECT_URI=https://yourdomain.com/auth/callback/weibo

# æŠ–éŸ³ç™»å½•
DOUYIN_CLIENT_KEY=your_douyin_client_key
DOUYIN_CLIENT_SECRET=your_douyin_client_secret
DOUYIN_REDIRECT_URI=https://yourdomain.com/auth/callback/douyin

# Googleç™»å½•
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
GOOGLE_REDIRECT_URI=https://yourdomain.com/auth/callback/google

# Appleç™»å½•
APPLE_CLIENT_ID=your_apple_client_id
APPLE_TEAM_ID=your_apple_team_id
APPLE_KEY_ID=your_apple_key_id
APPLE_PRIVATE_KEY_PATH=./keys/apple-private-key.p8
APPLE_REDIRECT_URI=https://yourdomain.com/auth/callback/apple
```

---

### Phase 6: å‰ç«¯ç¬¬ä¸‰æ–¹ç™»å½•å®ç° (1å‘¨)

#### æ­¥éª¤ 6.1: åˆ›å»ºç¤¾äº¤ç™»å½•æŒ‰é’®ç»„ä»¶

**æ–‡ä»¶**: `frontend/src/components/auth/SocialLoginButtons.tsx`

å®Œæ•´ä»£ç è§ä¹‹å‰æä¾›çš„è¯¦ç»†å®ç°ï¼ŒåŒ…å«æ‰€æœ‰7ç§ç™»å½•æ–¹å¼çš„æŒ‰é’®ã€‚

#### æ­¥éª¤ 6.2: åˆ›å»º OAuth å›è°ƒå¤„ç†é¡µé¢

**æ–‡ä»¶**: `frontend/src/pages/Auth/OAuthCallback.tsx`

å®Œæ•´ä»£ç è§ä¹‹å‰æä¾›çš„è¯¦ç»†å®ç°ã€‚

#### æ­¥éª¤ 6.3: æ·»åŠ è·¯ç”±é…ç½®

**æ–‡ä»¶**: `frontend/src/App.tsx`

**æ·»åŠ OAuthå›è°ƒè·¯ç”±**:

```typescript
import { OAuthCallback } from '@/pages/Auth/OAuthCallback';

// åœ¨ Routes ä¸­æ·»åŠ 
<Route path="/auth/callback/:provider" element={<OAuthCallback />} />
```

#### æ­¥éª¤ 6.4: é›†æˆåˆ°ç™»å½•é¡µé¢

**æ–‡ä»¶**: `frontend/src/pages/Auth/LoginPage.tsx`

```typescript
import React from 'react';
import { Card, Divider } from 'antd';
import { SocialLoginButtons } from '@/components/auth/SocialLoginButtons';
import { LoginForm } from '@/components/auth/LoginForm'; // å‡è®¾å·²å­˜åœ¨

const LoginPage: React.FC = () => {
  return (
    <div className="login-page" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100vh' }}>
      <Card style={{ width: 400 }}>
        <h2 style={{ textAlign: 'center' }}>ç™»å½•</h2>
        
        {/* ä¼ ç»Ÿç™»å½•è¡¨å• */}
        <LoginForm />
        
        <Divider>æˆ–ä½¿ç”¨ç¬¬ä¸‰æ–¹ç™»å½•</Divider>
        
        {/* ç¬¬ä¸‰æ–¹ç™»å½•æŒ‰é’® */}
        <SocialLoginButtons />
      </Card>
    </div>
  );
};

export default LoginPage;
```

---

### Phase 7: æµ‹è¯•ä¸ä¼˜åŒ– (3å¤©)

#### æµ‹è¯•æ¸…å•

**åŠŸèƒ½æµ‹è¯•**:
- [ ] æ¯ä¸ªå¹³å°çš„OAuthæˆæƒæµç¨‹
- [ ] ç”¨æˆ·ä¿¡æ¯è·å–
- [ ] æ–°ç”¨æˆ·æ³¨å†Œ
- [ ] å·²æœ‰ç”¨æˆ·ç™»å½•
- [ ] è´¦å·ç»‘å®šåŠŸèƒ½
- [ ] è´¦å·è§£ç»‘åŠŸèƒ½

**å®‰å…¨æµ‹è¯•**:
- [ ] Stateå‚æ•°éªŒè¯ï¼ˆé˜²CSRFï¼‰
- [ ] Tokenå®‰å…¨å­˜å‚¨
- [ ] APIæ¥å£é‰´æƒ
- [ ] æ•æ„Ÿä¿¡æ¯åŠ å¯†

**å…¼å®¹æ€§æµ‹è¯•**:
- [ ] å„æµè§ˆå™¨å…¼å®¹æ€§
- [ ] ç§»åŠ¨ç«¯é€‚é…
- [ ] å¾®ä¿¡å†…ç½®æµè§ˆå™¨
- [ ] å„å¹³å°APPå†…

---

### Phase 8: é›†æˆæµ‹è¯•ä¸ä¸Šçº¿å‡†å¤‡ (3å¤©)

#### å‡†å¤‡å·¥ä½œ

1. **é…ç½®ç”Ÿäº§ç¯å¢ƒ**
   - é…ç½®æ­£å¼çš„OAuthå›è°ƒåŸŸå
   - ç”³è¯·å„å¹³å°çš„ç”Ÿäº§ç¯å¢ƒåº”ç”¨
   - é…ç½®HTTPSè¯ä¹¦

2. **æ•°æ®è¿ç§»**
   - è¿è¡Œæ‰€æœ‰æ•°æ®åº“è¿ç§»
   - éªŒè¯æ•°æ®å®Œæ•´æ€§

3. **æ€§èƒ½ä¼˜åŒ–**
   - æ·»åŠ Redisç¼“å­˜OAuth token
   - ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢
   - æ·»åŠ CDNåŠ é€Ÿ

4. **ç›‘æ§å‘Šè­¦**
   - é…ç½®æ—¥å¿—æ”¶é›†
   - é…ç½®é”™è¯¯å‘Šè­¦
   - é…ç½®æ€§èƒ½ç›‘æ§

---

## ğŸ“ æ³¨æ„äº‹é¡¹

### å¼€å‘æ³¨æ„äº‹é¡¹

1. **OAuthå®‰å…¨**
   - å§‹ç»ˆéªŒè¯ state å‚æ•°
   - ä½¿ç”¨ HTTPS
   - ä¸åœ¨å‰ç«¯æš´éœ² client_secret
   - å®ç°tokenåˆ·æ–°æœºåˆ¶

2. **å¹³å°å·®å¼‚**
   - ä¸åŒå¹³å°çš„æˆæƒæµç¨‹ç•¥æœ‰å·®å¼‚
   - æ³¨æ„ç”¨æˆ·ä¿¡æ¯å­—æ®µçš„å·®å¼‚
   - å¤„ç†å¥½å¹³å°ç‰¹æœ‰çš„é”™è¯¯ç 

3. **ç”¨æˆ·ä½“éªŒ**
   - æä¾›æ¸…æ™°çš„é”™è¯¯æç¤º
   - æ”¯æŒå–æ¶ˆæˆæƒ
   - è®°ä½ç”¨æˆ·çš„ç™»å½•é€‰æ‹©

4. **æ•°æ®éšç§**
   - éµå®ˆå„å¹³å°çš„æ•°æ®ä½¿ç”¨è§„èŒƒ
   - è·å¾—ç”¨æˆ·æˆæƒæ‰èƒ½ä½¿ç”¨æ•°æ®
   - æä¾›æ•°æ®åˆ é™¤åŠŸèƒ½

### è¿ç»´æ³¨æ„äº‹é¡¹

1. **ç›‘æ§æŒ‡æ ‡**
   - OAuthæˆæƒæˆåŠŸç‡
   - å„å¹³å°ç™»å½•å æ¯”
   - é”™è¯¯ç‡å’Œå“åº”æ—¶é—´
   - Tokenåˆ·æ–°é¢‘ç‡

2. **åº”æ€¥é¢„æ¡ˆ**
   - æŸä¸ªå¹³å°æœåŠ¡å¼‚å¸¸çš„é™çº§æ–¹æ¡ˆ
   - å¿«é€Ÿå›æ»šæœºåˆ¶
   - ç”¨æˆ·æ•°æ®å¤‡ä»½ç­–ç•¥

3. **æ–‡æ¡£ç»´æŠ¤**
   - æ›´æ–°APIæ–‡æ¡£
   - è®°å½•å„å¹³å°çš„ç‰¹æ®Šå¤„ç†
   - ç»´æŠ¤æ•…éšœå¤„ç†æ‰‹å†Œ

---

## ğŸ¯ éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶

- [ ] æ”¯æŒHTML5ã€å¾®ä¿¡ã€æŠ–éŸ³ä¸‰ç§æ¸¸æˆå¹³å°
- [ ] æ”¯æŒ7ç§ç¬¬ä¸‰æ–¹ç™»å½•æ–¹å¼
- [ ] æ¸¸æˆå¯åŠ¨æˆåŠŸç‡ > 95%
- [ ] OAuthæˆæƒæˆåŠŸç‡ > 98%
- [ ] æ”¯æŒå¹³å°è‡ªåŠ¨æ£€æµ‹
- [ ] æ”¯æŒå¤šå¹³å°æ¸¸æˆåˆ‡æ¢
- [ ] æ”¯æŒè´¦å·ç»‘å®š/è§£ç»‘

### æ€§èƒ½éªŒæ”¶

- [ ] æ¸¸æˆåŠ è½½æ—¶é—´ < 3ç§’
- [ ] OAuthè·³è½¬å»¶è¿Ÿ < 500ms
- [ ] APIå“åº”æ—¶é—´ < 200ms
- [ ] äºŒç»´ç ç”Ÿæˆæ—¶é—´ < 1ç§’

### å®‰å…¨éªŒæ”¶

- [ ] é€šè¿‡å®‰å…¨æ‰«æ
- [ ] CSRFé˜²æŠ¤æœ‰æ•ˆ
- [ ] Tokenå®‰å…¨å­˜å‚¨
- [ ] æ— æ•æ„Ÿä¿¡æ¯æ³„éœ²

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å¾®ä¿¡å¼€æ”¾å¹³å°æ–‡æ¡£](https://developers.weixin.qq.com/doc/)
- [æŠ–éŸ³å¼€æ”¾å¹³å°æ–‡æ¡£](https://developer.open-douyin.com/)
- [æ”¯ä»˜å®å¼€æ”¾å¹³å°æ–‡æ¡£](https://opendocs.alipay.com/)
- [å¾®åšå¼€æ”¾å¹³å°æ–‡æ¡£](https://open.weibo.com/wiki/é¦–é¡µ)
- [Google OAuthæ–‡æ¡£](https://developers.google.com/identity/protocols/oauth2)
- [Apple Sign Inæ–‡æ¡£](https://developer.apple.com/sign-in-with-apple/)

---

## ğŸ†˜ é—®é¢˜åé¦ˆ

å¦‚é‡åˆ°é—®é¢˜ï¼Œè¯·æŒ‰ä»¥ä¸‹æ ¼å¼æä¾›ä¿¡æ¯ï¼š

1. **é—®é¢˜æè¿°**ï¼šè¯¦ç»†æè¿°é‡åˆ°çš„é—®é¢˜
2. **å¤ç°æ­¥éª¤**ï¼šå¦‚ä½•é‡ç°é—®é¢˜
3. **é”™è¯¯ä¿¡æ¯**ï¼šå®Œæ•´çš„é”™è¯¯æ—¥å¿—
4. **ç¯å¢ƒä¿¡æ¯**ï¼šæ“ä½œç³»ç»Ÿã€æµè§ˆå™¨ç‰ˆæœ¬ç­‰
5. **æˆªå›¾**ï¼šå¦‚æœ‰å¿…è¦ï¼Œæä¾›æˆªå›¾

---

**æ–‡æ¡£ç»´æŠ¤è€…**: GameHub å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2024-11-12  
**ç‰ˆæœ¬**: v1.0

